
https://www.geeksforgeeks.org/first-negative-integer-every-window-size-k/
Efficient Approach: It is a variation of the problem of Sliding Window Maximum. 
We create a Dequeue, Di of capacity k, that stores only useful elements of the current window of k elements. An element is useful if it is in the current window and it is a negative integer. We process all array elements one by one and maintain Di to contain useful elements of current window and these useful elements are all negative integers. For a particular window, if Di is not empty then the element at front of the Di is the first negative integer for that window, else that window does not contain a negative integer.

// Java implementation to find the
// first negative integer in
// every window of size k
import java.util.*;
class GFG
{
 
// function to find the first negative
// integer in every window of size k
static void printFirstNegativeInteger(int arr[],
                                      int n, int k)
{
    // A Double Ended Queue, Di that will
    // store indexes of useful array elements
    // for the current window of size k.
    // The useful elements are all negative integers.
    LinkedList<Integer> Di = new LinkedList<>();
 
    // Process first k (or first window)
    // elements of array
    int i;
    for (i = 0; i < k; i++)
     
        // Add current element at the rear of Di
        // if it is a negative integer
        if (arr[i] < 0)
            Di.add(i);
     
    // Process rest of the elements,
    // i.e., from arr[k] to arr[n-1]
    for ( ; i < n; i++)
    {
        // if Di is not empty then the element
        // at the front of the queue is the first
        // negative integer of the previous window
        if (!Di.isEmpty())
            System.out.print(arr[Di.peek()] + " ");
         
        // else the window does not have a
        // negative integer
        else
            System.out.print("0" + " ");
 
        // Remove the elements which are
        // out of this window
        while ((!Di.isEmpty()) &&
                 Di.peek() < (i - k + 1))
            Di.remove(); // Remove from front of queue
 
        // Add current element at the rear of Di
        // if it is a negative integer
        if (arr[i] < 0)
            Di.add(i);
    }
 
    // Print the first negative
    // integer of last window
    if (!Di.isEmpty())
        System.out.print(arr[Di.peek()] + " ");
    else
        System.out.print("0" + " ");    
}
 
// Driver Code
public static void main(String[] args)
{
    int arr[] = {12, -1, -7, 8, -15, 30, 16, 28};
    int n = arr.length;
    int k = 3;
    printFirstNegativeInteger(arr, n, k);
}
}
 
// This code is contributed by PrinciRaj1992

Output: 

-1 -1 -7 -15 -15 0

Time Complexity: O(n) 
Auxiliary Space: O(k)
